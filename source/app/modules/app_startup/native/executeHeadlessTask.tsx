// app/modules/app_startup/native/executeHeadlessTask.tsx
export default (function(argFoo, argBar, argBaz, argCor, _, argFre, argPlu) {
    report = argBar;
    golfie = argBaz;
    zuuluu = argFre;
    oscard = argPlu;
    var _closure1_slot0 = report;
    var _closure1_slot1 = golfie;
    entity = argCor;
    var _closure1_slot2 = entity;
    var _closure1_slot3 = oscard;
    entity = function() { // Original name: _executeHeadlessTask
        report = undefined;
        entity = undefined;
        tangon = _closure1_slot4;
        zuuluu = function* (argFoo, argBar, argBaz) {
            entity = function* (argFoo, argBar, argBaz) { // Original name: ?anon_0_
                _fun00001: for(var _fun00002_ip = 0; ; ) switch(_fun00002_ip) {
 0:
                    StartGenerator();
                    backup = argFoo;
                    ResumeGenerator(result_out_reg=0, return_bool_out_reg=1);
                    if(michal) { _fun00002_ip = 1559; continue _fun00001 }
 13:
                    verify = backup;
                    kiloes = argBar;
                    foxtra = argBaz;
                    report = undefined;
                    zuuluu = undefined;
                    tangon = undefined;
                    option = undefined;
                    golfie = _closure1_slot1;
                    romeon = _closure1_slot3;
                    michal = 4;
                    michal = romeon[michal];
                    sizing = golfie.bind(report)(michal);
                    oscard = global;
                    michal = oscard.HermesInternal;
                    yankee = michal.concat;
                    michal = 'Task ';
                    record = yankee.bind(michal)(backup);
                    yankee = sizing.prototype;
                    yankee = Object.create(yankee, {constructor: {value: sizing}});
                    cntext = yankee;
                    michal = new cntext[sizing](record, config);
                    zuuluu = michal instanceof Object ? michal : yankee;
                    yankee = oscard.Date;
                    michal = yankee.now;
                    tangon = michal.bind(yankee)();
                    yankee = 5;
                    michal = romeon[yankee];
                    output = golfie.bind(report)(michal);
                    sizing = output.addBreadcrumb;
                    michal = {};
                    result = 'Executing headless task.';
                    michal['message'] = result;
                    result = {};
                    result['name'] = backup;
                    michal['data'] = result;
                    michal = sizing.bind(output)(michal);
                    michal = 6;
                    michal = romeon[michal];
                    golfie = golfie.bind(report)(michal);
                    michal = golfie.recordStartHeadlessTask;
                    michal = michal.bind(golfie)(backup);
                    golfie = _closure1_slot0;
                    michal = 7;
                    michal = romeon[michal];
                    golfie = golfie.bind(report)(michal);
                    michal = golfie.closeFastConnectSocket;
                    michal = michal.bind(golfie)();
                    romeon = false;
                    option = false;
 210: // try_start_0
                    golfie = _closure1_slot1;
                    michal = _closure1_slot3;
                    backup = 8;
                    michal = michal[backup];
                    michal = golfie.bind(report)(michal);
                    michal = michal.wasEverActive;
                    if(michal) { _fun00002_ip = 270; continue _fun00001 }
 239:
                    golfie = _closure1_slot1;
                    michal = _closure1_slot3;
                    michal = michal[backup];
                    michal = golfie.bind(report)(michal);
                    golfie = michal.extraProperties;
                    michal = true;
                    golfie['headless_task_ran'] = michal;
 270:
                    michal = _closure1_slot5;
                    golfie = michal.currentState;
                    michal = 'active';
                    if(!(michal !== golfie)) { _fun00002_ip = 341; continue _fun00001 }
 288:
                    backup = zuuluu;
                    golfie = backup.log;
                    michal = 'Pausing socket in headless task because app state is not active';
                    michal = golfie.bind(backup)(michal);
                    golfie = _closure1_slot2;
                    backup = _closure1_slot3;
                    michal = 9;
                    michal = backup[michal];
                    backup = golfie.bind(report)(michal);
                    golfie = backup.setIsPaused;
                    michal = true;
                    michal = golfie.bind(backup)(michal);
 341:
                    golfie = _closure1_slot1;
                    michal = _closure1_slot3;
                    backup = 10;
                    michal = michal[backup];
                    output = golfie.bind(report)(michal);
                    sizing = output.track;
                    michal = _closure1_slot8;
                    golfie = michal.HEADLESS_TASK_INVOKED;
                    michal = {};
                    result = _closure1_slot5;
                    result = result.currentState;
                    michal['client_app_state'] = result;
                    result = verify;
                    michal['name'] = result;
                    michal = sizing.bind(output)(golfie, michal);
                    michal = _closure1_slot6;
                    michal = michal.bind(report)();
                    SaveGenerator(address=418);
 416:
                    return michal;
 418:
                    ResumeGenerator(result_out_reg=1, return_bool_out_reg=6);
                    if(golfie) { _fun00002_ip = 1152; continue _fun00001 }
 427:
                    output = zuuluu;
                    sizing = output.log;
                    golfie = 'initHeadlessTask completed';
                    golfie = sizing.bind(output)(golfie);
                    golfie = _closure1_slot7;
                    golfie = golfie.promise;
                    SaveGenerator(address=461);
 459:
                    return golfie;
 461:
                    ResumeGenerator(result_out_reg=6, return_bool_out_reg=15);
                    if(sizing) { _fun00002_ip = 946; continue _fun00001 }
 470:
                    result = zuuluu;
                    output = result.log;
                    sizing = 'Flux Initialized';
                    sizing = output.bind(result)(sizing);
                    kiloes = kiloes.bind(report)();
                    foxtra = kiloes.bind(report)(foxtra);
                    SaveGenerator(address=503);
 501:
                    return foxtra;
 503:
                    ResumeGenerator(result_out_reg=12, return_bool_out_reg=14);
                    if(kiloes) { _fun00002_ip = 740; continue _fun00001 }
 512:
                    option = true;
                    output = zuuluu;
                    sizing = output.log;
                    kiloes = 'Task completed successfully';
                    kiloes = sizing.bind(output)(kiloes);
 534: // try_end0
                    sizing = oscard.Date;
                    kiloes = sizing.now;
                    sizing = kiloes.bind(sizing)();
                    kiloes = tangon;
                    echoed = sizing - kiloes;
                    sizing = _closure1_slot1;
                    kiloes = _closure1_slot3;
                    output = kiloes[yankee];
                    ctrled = sizing.bind(report)(output);
                    result = ctrled.addBreadcrumb;
                    output = {};
                    update = 'Finished headless task.';
                    output['message'] = update;
                    vacuum = {};
                    source = verify;
                    vacuum['name'] = source;
                    update = option;
                    vacuum['success'] = update;
                    sequen = 'ms';
                    sequen = echoed + sequen;
                    vacuum['duration'] = sequen;
                    output['data'] = vacuum;
                    output = result.bind(ctrled)(output);
                    ctrled = zuuluu;
                    result = ctrled.log;
                    output = 'Unpausing socket';
                    output = result.bind(ctrled)(output);
                    result = _closure1_slot2;
                    output = 9;
                    output = kiloes[output];
                    result = result.bind(report)(output);
                    output = result.setIsPaused;
                    output = output.bind(result)(romeon);
                    kiloes = kiloes[backup];
                    result = sizing.bind(report)(kiloes);
                    output = result.track;
                    kiloes = _closure1_slot8;
                    sizing = kiloes.HEADLESS_TASK_COMPLETED;
                    kiloes = {};
                    ctrled = _closure1_slot5;
                    ctrled = ctrled.currentState;
                    kiloes['client_app_state'] = ctrled;
                    kiloes['name'] = source;
                    kiloes['success'] = update;
                    kiloes['duration_ms'] = echoed;
                    kiloes = output.bind(result)(sizing, kiloes);
                    return report;
 740:
                    sizing = oscard.Date;
                    kiloes = sizing.now;
                    sizing = kiloes.bind(sizing)();
                    kiloes = tangon;
                    echoed = sizing - kiloes;
                    sizing = _closure1_slot1;
                    kiloes = _closure1_slot3;
                    output = kiloes[yankee];
                    ctrled = sizing.bind(report)(output);
                    result = ctrled.addBreadcrumb;
                    output = {};
                    update = 'Finished headless task.';
                    output['message'] = update;
                    vacuum = {};
                    source = verify;
                    vacuum['name'] = source;
                    update = option;
                    vacuum['success'] = update;
                    sequen = 'ms';
                    sequen = echoed + sequen;
                    vacuum['duration'] = sequen;
                    output['data'] = vacuum;
                    output = result.bind(ctrled)(output);
                    ctrled = zuuluu;
                    result = ctrled.log;
                    output = 'Unpausing socket';
                    output = result.bind(ctrled)(output);
                    result = _closure1_slot2;
                    output = 9;
                    output = kiloes[output];
                    result = result.bind(report)(output);
                    output = result.setIsPaused;
                    output = output.bind(result)(romeon);
                    kiloes = kiloes[backup];
                    result = sizing.bind(report)(kiloes);
                    output = result.track;
                    kiloes = _closure1_slot8;
                    sizing = kiloes.HEADLESS_TASK_COMPLETED;
                    kiloes = {};
                    ctrled = _closure1_slot5;
                    ctrled = ctrled.currentState;
                    kiloes['client_app_state'] = ctrled;
                    kiloes['name'] = source;
                    kiloes['success'] = update;
                    kiloes['duration_ms'] = echoed;
                    kiloes = output.bind(result)(sizing, kiloes);
                    return foxtra;
 946:
                    kiloes = oscard.Date;
                    foxtra = kiloes.now;
                    kiloes = foxtra.bind(kiloes)();
                    foxtra = tangon;
                    result = kiloes - foxtra;
                    kiloes = _closure1_slot1;
                    foxtra = _closure1_slot3;
                    sizing = foxtra[yankee];
                    source = kiloes.bind(report)(sizing);
                    output = source.addBreadcrumb;
                    sizing = {};
                    echoed = 'Finished headless task.';
                    sizing['message'] = echoed;
                    ctrled = {};
                    update = verify;
                    ctrled['name'] = update;
                    echoed = option;
                    ctrled['success'] = echoed;
                    vacuum = 'ms';
                    vacuum = result + vacuum;
                    ctrled['duration'] = vacuum;
                    sizing['data'] = ctrled;
                    sizing = output.bind(source)(sizing);
                    source = zuuluu;
                    output = source.log;
                    sizing = 'Unpausing socket';
                    sizing = output.bind(source)(sizing);
                    output = _closure1_slot2;
                    sizing = 9;
                    sizing = foxtra[sizing];
                    output = output.bind(report)(sizing);
                    sizing = output.setIsPaused;
                    sizing = sizing.bind(output)(romeon);
                    foxtra = foxtra[backup];
                    output = kiloes.bind(report)(foxtra);
                    sizing = output.track;
                    foxtra = _closure1_slot8;
                    kiloes = foxtra.HEADLESS_TASK_COMPLETED;
                    foxtra = {};
                    source = _closure1_slot5;
                    source = source.currentState;
                    foxtra['client_app_state'] = source;
                    foxtra['name'] = update;
                    foxtra['success'] = echoed;
                    foxtra['duration_ms'] = result;
                    foxtra = sizing.bind(output)(kiloes, foxtra);
                    return golfie;
 1152:
                    foxtra = oscard.Date;
                    golfie = foxtra.now;
                    foxtra = golfie.bind(foxtra)();
                    golfie = tangon;
                    sizing = foxtra - golfie;
                    foxtra = _closure1_slot1;
                    golfie = _closure1_slot3;
                    kiloes = golfie[yankee];
                    update = foxtra.bind(report)(kiloes);
                    echoed = update.addBreadcrumb;
                    kiloes = {};
                    output = 'Finished headless task.';
                    kiloes['message'] = output;
                    source = {};
                    result = verify;
                    source['name'] = result;
                    output = option;
                    source['success'] = output;
                    ctrled = 'ms';
                    ctrled = sizing + ctrled;
                    source['duration'] = ctrled;
                    kiloes['data'] = source;
                    kiloes = echoed.bind(update)(kiloes);
                    update = zuuluu;
                    echoed = update.log;
                    kiloes = 'Unpausing socket';
                    kiloes = echoed.bind(update)(kiloes);
                    echoed = _closure1_slot2;
                    kiloes = 9;
                    kiloes = golfie[kiloes];
                    echoed = echoed.bind(report)(kiloes);
                    kiloes = echoed.setIsPaused;
                    kiloes = kiloes.bind(echoed)(romeon);
                    golfie = golfie[backup];
                    kiloes = foxtra.bind(report)(golfie);
                    backup = kiloes.track;
                    golfie = _closure1_slot8;
                    foxtra = golfie.HEADLESS_TASK_COMPLETED;
                    golfie = {};
                    echoed = _closure1_slot5;
                    echoed = echoed.currentState;
                    golfie['client_app_state'] = echoed;
                    golfie['name'] = result;
                    golfie['success'] = output;
                    golfie['duration_ms'] = sizing;
                    golfie = backup.bind(kiloes)(foxtra, golfie);
                    return michal;
 1358: // catch_target0
                    CatchBlockStart(arg_register=1);
                    golfie = oscard.Date;
                    oscard = golfie.now;
                    oscard = oscard.bind(golfie)();
                    golfie = oscard - tangon;
                    tangon = _closure1_slot1;
                    oscard = _closure1_slot3;
                    yankee = oscard[yankee];
                    backup = tangon.bind(report)(yankee);
                    foxtra = backup.addBreadcrumb;
                    yankee = {};
                    kiloes = 'Finished headless task.';
                    yankee['message'] = kiloes;
                    kiloes = {};
                    kiloes['name'] = verify;
                    kiloes['success'] = option;
                    sizing = 'ms';
                    sizing = golfie + sizing;
                    kiloes['duration'] = sizing;
                    yankee['data'] = kiloes;
                    yankee = foxtra.bind(backup)(yankee);
                    foxtra = zuuluu;
                    yankee = foxtra.log;
                    zuuluu = 'Unpausing socket';
                    zuuluu = yankee.bind(foxtra)(zuuluu);
                    yankee = _closure1_slot2;
                    zuuluu = 9;
                    zuuluu = oscard[zuuluu];
                    yankee = yankee.bind(report)(zuuluu);
                    zuuluu = yankee.setIsPaused;
                    zuuluu = zuuluu.bind(yankee)(romeon);
                    zuuluu = 10;
                    zuuluu = oscard[zuuluu];
                    oscard = tangon.bind(report)(zuuluu);
                    report = oscard.track;
                    zuuluu = _closure1_slot8;
                    tangon = zuuluu.HEADLESS_TASK_COMPLETED;
                    zuuluu = {};
                    offset = _closure1_slot5;
                    offset = offset.currentState;
                    zuuluu['client_app_state'] = offset;
                    zuuluu['name'] = verify;
                    zuuluu['success'] = option;
                    zuuluu['duration_ms'] = golfie;
                    zuuluu = report.bind(oscard)(tangon, zuuluu);
                    throw michal;
 1559:
                    return entity;
                }
            };
            return entity;
        };
        tangon = tangon.bind(report)(zuuluu);
        _closure1_slot9 = tangon;
        zuuluu = tangon.apply;
        entity = arguments;
        michal = entity;
        entity = this;
        entity = zuuluu.bind(tangon)(entity, michal);
        return entity;
    };
    var _closure1_slot9 = entity;
    entity = global;
    verify = entity.Object;
    option = verify.defineProperty;
    tangon = {};
    entity = true;
    tangon['value'] = entity;
    entity = '__esModule';
    entity = option.bind(verify)(zuuluu, entity, tangon);
    entity = 0;
    tangon = oscard[entity];
    entity = undefined;
    tangon = golfie.bind(entity)(tangon);
    var _closure1_slot4 = tangon;
    tangon = 1;
    tangon = oscard[tangon];
    tangon = report.bind(entity)(tangon);
    tangon = tangon.AppState;
    var _closure1_slot5 = tangon;
    tangon = 2;
    tangon = oscard[tangon];
    tangon = report.bind(entity)(tangon);
    golfie = tangon.initHeadlessTask;
    var _closure1_slot6 = golfie;
    tangon = tangon.applicationReady;
    var _closure1_slot7 = tangon;
    tangon = 3;
    tangon = oscard[tangon];
    tangon = report.bind(entity)(tangon);
    tangon = tangon.AnalyticEvents;
    var _closure1_slot8 = tangon;
    tangon = 11;
    tangon = oscard[tangon];
    oscard = report.bind(entity)(tangon);
    report = oscard.fileFinishedImporting;
    tangon = 'modules/app_startup/native/executeHeadlessTask.tsx';
    tangon = report.bind(oscard)(tangon);
    michal = function() { // Original name: executeHeadlessTask
        entity = undefined;
        tangon = _closure1_slot9;
        zuuluu = tangon.apply;
        entity = arguments;
        michal = entity;
        entity = this;
        entity = zuuluu.bind(tangon)(entity, michal);
        return entity;
    };
    zuuluu['default'] = michal;
    return entity;
})();